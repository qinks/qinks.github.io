<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Centos下NFS使用与配置]]></title>
    <url>%2F2019%2F01%2F28%2FCentos7%E4%B8%8BNFS%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[NFS是Network File System的缩写，即网络文件系统。客户端通过挂载的方式将NFS服务器端共享的数据目录挂载到本地目录下。 一、NFS的工作流程12341、由程序在NFS客户端发起存取文件的请求，客户端本地的RPC(rpcbind)服务会通过网络向NFS服务端的RPC的111端口发出文件存取功能的请求。2、NFS服务端的RPC找到对应已注册的NFS端口，通知客户端RPC服务。3、客户端获取正确的端口，并与NFS daemon联机存取数据。4、存取数据成功后，返回前端访问程序，完成一次存取操作。 所以无论客户端 和服务端都需要用NFS，必须安装RPC服务。 NFS的RPC服务，在Centos5下名为portmap,Centos6下名称为rpcbind. 二、Centos7搭建NFS服务器实例 服务器系统 角色 IP CentOS7-150–server NFS服务器端 192.168.10.150 CentOS7-151-localhost NFS客户端 192.168.10.151 共享CentOS7-150–server中/data/bbs目录，使192.168.10.1 IP段所有主机都可以访问 1、因是测试环境，先关闭selinux和firewalld 1)关闭selinux 1[root@service ~]# sed -i s#SELINUX=enforcing#SELINUX=disabled#g /etc/selinux/config 2）关闭firewalld防火墙 查看firewalld防火墙开机自动状态 12[root@service ~]# systemctl list-unit-files|grep enable|grep firewalldfirewalld.service enabled 关闭firewalld防火墙开机自动启 123[root@service ~]# systemctl disable firewalld.serviceRemoved symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service. 停止防火墙 1[root@service ~]# systemctl stop firewalld.service 查看防火墙状态 1234567891011121314[root@service ~]# systemctl status firewalld.service● firewalld.service - firewalld - dynamic firewall daemon Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled) Active: inactive (dead) Docs: man:firewalld(1)Mar 14 18:52:24 localhost.localdomain systemd[1]: Starting firewalld - dynamic ....Mar 14 18:52:24 localhost.localdomain systemd[1]: Started firewalld - dynamic f....Mar 14 18:52:25 localhost.localdomain firewalld[573]: WARNING: ICMP type 'beyond...Mar 14 18:52:25 localhost.localdomain firewalld[573]: WARNING: beyond-scope: INV...Mar 14 18:52:25 localhost.localdomain firewalld[573]: WARNING: ICMP type 'failed...Mar 14 18:52:25 localhost.localdomain firewalld[573]: WARNING: failed-policy: IN...Mar 14 18:52:25 localhost.localdomain firewalld[573]: WARNING: ICMP type 'reject..Mar 14 18:52:25 localhost.localdomain firewalld[573]: WARNING: reject-route: INV...Mar 14 11:21:43 service systemd[1]: Stopping firewalld - dynamic firewall daemon...Mar 14 11:21:43 service systemd[1]: Stopped firewalld - dynamic firewall daemon.Hint: Some lines were ellipsized, use -l to show in full. 2、服务端部署 1)检查系统版本及NFS服务nfs-utils 和rpcbind有没有安装 123[root@service ~]# cat /etc/redhat-release CentOS Linux release 7.4.1708 (Core) [root@service ~]# rpm -qa nfs-utils rpcbind 2）安装NFS服务nfs-untils和rpcbind 1[root@service ~]# yum install nfs-utils rpcbind -y 3）启动rpcbind服务（一定要先启动rpcbind服务再启动nfs服务) 查看rpcbind服务状态 1[root@service ~]# systemctl status rpcbind.service 启动rpcbind服务 1[root@service ~]# systemctl start rpcbind.service 查看rpc 12345678910111213[root@service ~]# lsof -i :111COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEsystemd 1 root 33u IPv6 25136 0t0 TCP *:sunrpc (LISTEN)systemd 1 root 38u IPv4 25137 0t0 TCP *:sunrpc (LISTEN)rpcbind 9227 rpc 4u IPv6 25136 0t0 TCP *:sunrpc (LISTEN)rpcbind 9227 rpc 5u IPv4 25137 0t0 TCP *:sunrpc (LISTEN)rpcbind 9227 rpc 8u IPv4 33497 0t0 UDP *:sunrpc rpcbind 9227 rpc 10u IPv6 33499 0t0 UDP *:sunrpc [root@service ~]# netstat -lntup|grep rpcbindudp 0 0 0.0.0.0:922 0.0.0.0:* 9227/rpcbind udp 0 0 0.0.0.0:111 0.0.0.0:* 9227/rpcbind udp6 0 0 :::922 :::* 9227/rpcbind udp6 0 0 :::111 :::* 9227/rpcbind 查看nfs服务向rpc注册的端 口信息 12345678[root@service ~]# rpcinfo -p localhost program vers proto port service 100000 4 tcp 111 portmapper 100000 3 tcp 111 portmapper 100000 2 tcp 111 portmapper 100000 4 udp 111 portmapper 100000 3 udp 111 portmapper 100000 2 udp 111 portmapper 把rpcbind另入开机自启动 123[root@service ~]# systemctl enable rpcbind.service[root@service ~]# systemctl list-unit-files|grep enabled|grep rpcbindrpcbind.socket enabled 4)启动NFS服务并查看其状态 12[root@service ~]# systemctl start nfs.service[root@service ~]# systemctl status nfs.service 把NFS服务加入开机自启动并查看其状态 12[root@service ~]# systemctl enable nfs.service[root@service ~]# systemctl list-unit-files|grep nfs 5）授权nfsnobody于/data/bbs让客户端挂载后可写可读 1[root@service /]# chown nfsnobody:nfsnobody /data/bbs 6）创建测试目录及文件 12[root@service ~]# mkdir /data/bbs -p[root@service ~]# mkdir /data/bbs/test.txt 7)配置NFS服务的export文件 1[root@service ~]# echo "/data/bbs/ 192.168.10.1/24(rw,sync,root_squash)"&gt;&gt;/etc/exports 重新加载nfs配置文件 12[root@service ~]# exportfs -rvexporting 192.168.10.1/24:/data/bbs exportfs：NFS服务端发布共享控制命令。-r：表示重新刷新共享。-a：表示将配置文件/etc/exports中的所有定义共享发布出去。-v：显示确认共享设置。-u：表示不发布共享。 查看nfs服务器挂载情况 123[root@service ~]# showmount -e localhostExport list for localhost:/data/bbs 192.168.10.1/24 ro：目录只读 rw：目录读写 sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性 async：将数据先保存在内存缓冲区中，必要时才写入磁盘 all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组(nfsnobody) no_all_squash：与all_squash取反(默认设置) root_squash：将root用户及所属组都映射为匿名用户或用户组(默认设置) no_root_squash：与rootsquash取反 anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户(UID=xxx) anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户 3、客户端配置 1[root@localhost ~]# yum install nfs-utils rpcbind 把rpcbind加入开机自启动 1[root@localhost bbs]# systemctl enable rpcbind.service 创建测试目录文件 1[root@localhost ~]# mkdir /data/bbs/ -p 扫描NFS服务器的文件共享列表 123[root@localhost bbs]# showmount -e 192.168.10.150Export list for 192.168.10.150:/data/bbs 192.168.10.1/24 把服务器的目录挂载到客户端 的目录下 1234567891011[root@localhost ~]# mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs[root@localhost ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/sda3 18G 1004M 17G 6% /devtmpfs 479M 0 479M 0% /devtmpfs 489M 0 489M 0% /dev/shmtmpfs 489M 6.8M 482M 2% /runtmpfs 489M 0 489M 0% /sys/fs/cgroup/dev/sda1 497M 112M 385M 23% /boottmpfs 98M 0 98M 0% /run/user/0192.168.10.150:/data/bbs 18G 1006M 17G 6% /data/bbs 三、数据测试服务端 12[root@service /]# cd /data/bbs[root@service bbs]# touch a.txt 客户端 1[root@localhost ~]# ls /data/bbsa.txt 提示: 1.配置NFS服务端后，不用重启NFS服务，只要使用exportfs -rv 2.rpc主程序Centos5.8下为portmap 、Centos6.4和Centos7下为rpcbind 3.NFS共享目录不要授权于777权限，可以改所属主和组为nfsnobody，因为nfsnobody权限不是很大，也不能登陆 四、配置客户端 开机自动挂载NFS共享目录12345678910111213[root@localhost ~]# chmod +x /etc/rc.d/rc.local #centos7需要给rc.local赋予执行权限后，rc.local文件才能生效[root@localhost ~]# echo "mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs"&gt;&gt;/etc/rc.local[root@localhost ~]# cat /etc/rc.local#!/bin/bash# THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES## It is highly advisable to create own systemd services or udev rules# to run scripts during boot instead of using this file.## In contrast to previous versions due to parallel execution during boot# this script will NOT be run after all other services.## Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure# that this script will be executed during boot.mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs 五、客户端mount挂载优化在企业生产环境中，NFS客户端挂载的参数有noexec、nosuid、nodev、noatime、rsize、wsize、nodiratime等， 一般来说，NFS服务器共享的只是普通静态数据（图片、附件、视频），不需要执行suid、exec等权限，挂载的这个文件系统只能作为数据存取之用，无法执行程序，对于客户端来讲增加了安全性，例如：很多木马修改站点文件都是由上传入口上传的程序存储目录，然后执行，因此在挂载时，用下面的命令是有必要的， 普遍安全挂载参数： mount -t nfs -o nosuid,noexec,nodev,rw 192.168.10.150:/data/bbs /data/bbs 挂载的读写缓存 wsize和rsize写和读缓存 wsize和rsize的最大值 NFSV2 rsize\=8192 wsize=8192 NFSV3 rsize\=32768 wsize=32768 NFSV4 rsize\=65536 wsize=65536 现在一般centos5.8以上的系统都己经增加了读写缓存，如需修改可以加以上参数 例如： mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs ★mount的一些常用挂载优化参数： wsize和rsize写和读缓存 async 数据不同步写到磁盘，提高性参，但降低数据安全，不推荐使用 noatime和nodiratime 这两个选是说在读写磁盘时，不更新文件和目录的时间戳，而更新文件时间戳对于工作数据必要性不大，增加了磁盘IO的次数，拖慢系统性参，defaults 这个缺省值包括rw,suid,dev,exec,auto,nouser,and async cat /etc/fstab的结果默认大部人都是缺省值 noauto 不会自动挂载文件系统 noexec 不允许安装的直接执行任何二进制文件 ro 挂载一个只读文件系统 rw 挂载一个可写的文件系统 sync 把数据同步写入硬盘 nosuid 不允许设置用户标识或设置组标识符位 nodev 不解释字符或文件块特殊设备 intr表示可以中断 ★企业生产环境中nfs性参优化挂载例子： 12mount -t nfs -o noatime,nodiratime 192.168.10.150:/data/bbs /data/bbsmount -t nfs -o nosuid,noexec,nodev,noatime,nodiratime,intr,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs 如果是本地系统： mount -o defaults,async,noatime,data=writeback,barrier=0 /dev/sdb1 /mnt data=writeback,barrier=0 是日志文件系统的优化 提示：本地文件系统挂载如果加nodiratime会报错， 六、加优化参数和不加的数据写入测试★使用普通挂载 1[root@localhost ~]# mount -t nfs 192.168.10.150:/data/bbs /data/bbs 测试单个文件写入速度 12345678[root@localhost ~]# cd /data/bbs[root@localhost bbs]# time dd if=/dev/zero of=/data/bbs/dingjianfile bs=9k count=20002000+0 records in2000+0 records out18432000 bytes (18 MB) copied, 0.114592 s, 161 MB/sreal 0m0.125suser 0m0.000ssys 0m0.021s 测试批量创建文件的写入速度 1234[root@localhost bbs]# time for ((i=1;i&lt;10000;i++));do /bin/cp /bin/touch /data/bbs/test$i;donereal 2m2.877suser 0m10.242ssys 0m33.882s ★加优化参数挂载: 1[root@localhost bbs]#mount -t nfs -o noexec,nosuid,nodev,rw,rsize=65536,wsize=65536 192.168.10.150:/data/bbs /data/bbs 测试单个文件写入速度 1234567[root@localhost bbs]# time dd if=/dev/zero of=/data/bbs/dingjianfile bs=9k count=20002000+0 records in2000+0 records out18432000 bytes (18 MB) copied, 0.10043 s, 184 MB/sreal 0m0.107suser 0m0.001ssys 0m0.017s 测试批量创建文件的写入速度 1234[root@localhost bbs]# time for ((i=1;i&lt;10000;i++));do /bin/cp /bin/touch /data/bbs/test$i;donereal 1m38.526suser 0m9.989ssys 0m32.788s 七、配置fstab文件令开机自动加载网络文件系统和本地的文件系统(和rc.local效果一样)12345678910[root@localhost bbs]# vi /etc/fstab## /etc/fstab# Created by anaconda on Fri Mar 9 05:05:49 2018## Accessible filesystems, by reference, are maintained under '/dev/disk'# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#UUID=07347aff-3d84-4cd6-a0e7-ac145593622e / xfs defaults 0 0UUID=f6cdb812-e3ba-4154-8116-a39c68f74d98 /boot xfs defaults 0 0UUID=8b003ed3-3e5b-4f45-9530-41a412748c6a swap swap defaults 0 0192.168.10.150:/data/bbs /data/bbs nfs defaults,nosuid,noatime,nodiratime,noexec,nodev,intr,rsize=65536,wsize=65536 0 0~]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lsyncd实时同步搭建指南]]></title>
    <url>%2F2019%2F01%2F28%2FLsyncd%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[1. 几大实时同步工具比较1.1 inotify + rsync最近一直在寻求生产服务服务器上的同步替代方案，原先使用的是inotify + rsync，但随着文件数量的增大到100W+，目录下的文件列表就达20M，在网络状况不佳或者限速的情况下，变更的文件可能10来个才几M，却因此要发送的文件列表就达20M，严重减低的带宽的使用效率以及同步效率；更为要紧的是，加入inotifywait在5s内监控到10个小文件发生变化，便会触发10个rsync同步操作，结果就是真正需要传输的才2-3M的文件，比对的文件列表就达200M。使用这两个组合的好处在于，它们都是最基本的软件，可以通过不同选项做到很精确的控制，比如排除同步的目录，同步多个模块或同步到多个主机。 搭建过程参考Linux下同步工具inotify+rsync使用详解或这里。 1.2 sersync后来听同事说sersync这么个工具可以提高同步的性能，也解决了同步大文件时出现异常的问题，所以就尝试了一下。sersync是国内的一个开发者开源出来的，使用c++编写，采用多线程的方式进行同步，失败后还有重传机制，对临时文件过滤，自带crontab定时同步功能。网上看到有人说性能还不错，说一下我的观点： 国产开源，文档不是很全，在2011年之后就没更新了（googlecode都要快关闭了，其实可以转交其他人维护），网上关于它的使用和讨论都止于10年了 采用xml配置文件的方式，可读性比较好，但是有些原生的有些功能没有实现就没法使用了 无法实现多目录同步，只能通过多个配置文件启动多个进程 文件排除功能太弱。这个要看需求，不是每个人都需要排除子目录。而对于我的环境中，这个功能很重要，而且排除的规则较多 虽然提供插件的功能，但很鸡肋，因为软件本身没有持续更新，也没有看到贡献有其它插件出现（可能是我知识面不够，还用不到里面的refreshCDN plugin）。 虽然不懂c++，但大致看了下源码FileSynchronize，拼接rsync命令大概在273行左右，最后一个函数就是排除选项，简单一点可以将--exclude=改成--eclude-from来灵活控制。有机会再改吧。 另外，在作者的文章Sersync服务器同步程序 项目简介与设计框架评论中，说能解决上面rsync + inotify中所描述的问题。阅读了下源码，这个应该是没有解决，因为在拼接rsync命令时，后面的目的地址始终是针对module的，只要执行rsync命令，就会对整个目录进行遍历，发送要比对的文件列表，然后再发送变化的文件。sersync只是减少了监听的事件，减少了rsync的次数——这已经是很大的改进，但每次rsync没办法改变。（如有其它看法可与我讨论） 其实我们也不能要求每一个软件功能都十分健全，关键是看能否满足我们当下的特定的需求。所谓好的架构不是设计出来的，而是进化来的。目前使用sersync2没什么问题，而且看了它的设计思路应该是比较科学的，特别是过滤队列的设计。双向同步看起来也是可以实现。 1.3 lsyncd废话说这么多，本文就是介绍它了。有些博客说lsyncd是谷歌开源的，实际不是了，只是托管在了googlecode上而已，幸运的是已经迁移到github了：https://github.com/axkibe/lsyncd。 Lysncd 实际上是lua语言封装了 inotify 和 rsync 工具，采用了 Linux 内核（2.6.13 及以后）里的 inotify 触发机制，然后通过rsync去差异同步，达到实时的效果。我认为它最令人称道的特性是，完美解决了inotify + rsync海量文件同步带来的文件频繁发送文件列表的问题 —— 通过时间延迟或累计触发事件次数实现。另外，它的配置方式很简单，lua本身就是一种配置语言，可读性非常强。lsyncd也有多种工作模式可以选择，本地目录cp，本地目录rsync，远程目录rsyncssh。 实现简单高效的本地目录同步备份（网络存储挂载也当作本地目录），一个命令搞定。 2. 使用 lsyncd 本地目录实时备份这一节实现的功能是，本地目录source实时同步到另一个目录target，而在source下有大量的文件，并且有部分目录和临时文件不需要同步。 2.1 安装lsyncd安装lsyncd极为简单，已经收录在ubuntu的官方镜像源里，直接通过apt-get install lsyncd就可以。在Redhat系（我的环境是CentOS 6.2 x86_64 ），可以手动去下载lsyncd-2.1.5-6.fc21.x86_64.rpm，但首先你得安装两个依赖yum install lua lua-devel。也可以通过在线安装，需要epel-release扩展包： 12# rpm -ivh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm# yum install lsyncd 源码编译安装从源码编译安装可以使用最新版的lsyncd程序，但必须要相应的依赖库文件和编译工具：yum install lua lua-devel asciidoc cmake。 从googlecode lsyncd上下载的lsyncd-2.1.5.tar.gz，直接./configure、make &amp;&amp; make install就可以了。 从github上下载lsyncd-master.zip的2.1.5版本使用的是 cmake 编译工具，无法./configure： 1234# uzip lsyncd-master.zip# cd lsyncd-master# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/lsyncd-2.1.5# make &amp;&amp; make install 我这个版本编译时有个小bug，如果按照INSTALL在build目录中make，会提示： 123456[100%] Generating doc/lsyncd.1Updating the manpagea2x: failed: source file not found: doc/lsyncd.1.txtmake[2]: *** [doc/lsyncd.1] Error 1make[1]: *** [CMakeFiles/manpage.dir/all] Error 2make: *** [all] Error 2 解决办法是要么直接在解压目录下cmake，不要mkdir build，要么在CMakeList.txt中搜索doc字符串，在前面加上${PROJECT_SOURCE_DIR}。 2.2 lsyncd.conf下面都是在编译安装的情况下操作。 2.2.1 lsyncd同步配置1234567891011121314151617181920212223# cd /usr/local/lsyncd-2.1.5# mkdir etc var# vi etc/lsyncd.confsettings &#123; logfile =&quot;/usr/local/lsyncd-2.1.5/var/lsyncd.log&quot;, statusFile =&quot;/usr/local/lsyncd-2.1.5/var/lsyncd.status&quot;, inotifyMode = &quot;CloseWrite&quot;, maxProcesses = 7, -- nodaemon =true, &#125;sync &#123; default.rsync, source = &quot;/tmp/src&quot;, target = &quot;/tmp/dest&quot;, -- excludeFrom = &quot;/etc/rsyncd.d/rsync_exclude.lst&quot;, rsync = &#123; binary = &quot;/usr/bin/rsync&quot;, archive = true, compress = true, verbose = true &#125; &#125; 到这启动 lsycnd 就可以完成实时同步了，默认的许多参数可以满足绝大部分需求，非常简单。 2.2.2 lsyncd.conf配置选项说明settings里面是全局设置，--开头表示注释，下面是几个常用选项说明： logfile定义日志文件 stausFile定义状态文件 nodaemon=true表示不启用守护模式，默认 statusInterval将lsyncd的状态写入上面的statusFile的间隔，默认10秒 inotifyMode指定inotify监控的事件，默认是CloseWrite，还可以是Modify或CloseWrite or Modify maxProcesses同步进程的最大个数。假如同时有20个文件需要同步，而maxProcesses = 8，则最大能看到有8个rysnc进程 maxDelays累计到多少所监控的事件激活一次同步，即使后面的delay延迟时间还未到 sync里面是定义同步参数，可以继续使用maxDelays来重写settings的全局变量。一般第一个参数指定lsyncd以什么模式运行：rsync、rsyncssh、direct三种模式： default.rsync：本地目录间同步，使用rsync，也可以达到使用ssh形式的远程rsync效果，或daemon方式连接远程rsyncd进程；default.direct：本地目录间同步，使用cp、rm等命令完成差异文件备份；default.rsyncssh：同步到远程主机目录，rsync的ssh模式，需要使用key来认证 source同步的源目录，使用绝对路径。 target定义目的地址.对应不同的模式有几种写法：/tmp/dest：本地目录同步，可用于direct和rsync模式172.29.88.223:/tmp/dest：同步到远程服务器目录，可用于rsync和rsyncssh模式，拼接的命令类似于/usr/bin/rsync -ltsd --delete --include-from=- --exclude=* SOURCE TARGET，剩下的就是rsync的内容了，比如指定username，免密码同步172.29.88.223::module：同步到远程服务器目录，用于rsync模式三种模式的示例会在后面给出。 init这是一个优化选项，当init = false，只同步进程启动以后发生改动事件的文件，原有的目录即使有差异也不会同步。默认是true delay累计事件，等待rsync同步延时时间，默认15秒（最大累计到1000个不可合并的事件）。也就是15s内监控目录下发生的改动，会累积到一次rsync同步，避免过于频繁的同步。（可合并的意思是，15s内两次修改了同一文件，最后只同步最新的文件） excludeFrom排除选项，后面指定排除的列表文件，如excludeFrom = &quot;/etc/lsyncd.exclude&quot;，如果是简单的排除，可以使用exclude = LIST。这里的排除规则写法与原生rsync有点不同，更为简单： 监控路径里的任何部分匹配到一个文本，都会被排除，例如/bin/foo/bar可以匹配规则foo 如果规则以斜线/开头，则从头开始要匹配全部 如果规则以/结尾，则要匹配监控路径的末尾 ?匹配任何字符，但不包括/ *匹配0或多个字符，但不包括/ **匹配0或多个字符，可以是/ delete为了保持target与souce完全同步，Lsyncd默认会delete = true来允许同步删除。它除了false，还有startup、running值，请参考Lsyncd 2.1.x ‖ Layer 4 Config ‖ Default Behavior。 rsync（提示一下，delete和exclude本来都是rsync的选项，上面是配置在sync中的，我想这样做的原因是为了减少rsync的开销） bwlimit限速，单位kb/s，与rsync相同（这么重要的选项在文档里竟然没有标出） compress压缩传输默认为true。在带宽与cpu负载之间权衡，本地目录同步可以考虑把它设为false perms默认保留文件权限。 其它rsync的选项 其它还有rsyncssh模式独有的配置项，如host、targetdir、rsync_path、password_file，见后文示例。rsyncOps={&quot;-avz&quot;,&quot;--delete&quot;}这样的写法在2.1.*版本已经不支持。 lsyncd.conf可以有多个sync，各自的source，各自的target，各自的模式，互不影响。 2.3 启动lsyncd使用命令加载配置文件，启动守护进程，自动同步目录操作。 1lsyncd -log Exec /usr/local/lsyncd-2.1.5/etc/lsyncd.conf 2.4 lsyncd.conf其它模式示例以下配置本人都已经过验证可行，必须根据实际需要裁剪配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091settings &#123; logfile =&quot;/usr/local/lsyncd-2.1.5/var/lsyncd.log&quot;, statusFile =&quot;/usr/local/lsyncd-2.1.5/var/lsyncd.status&quot;, inotifyMode = &quot;CloseWrite&quot;, maxProcesses = 8, &#125;-- I. 本地目录同步，direct：cp/rm/mv。 适用：500+万文件，变动不大sync &#123; default.direct, source = &quot;/tmp/src&quot;, target = &quot;/tmp/dest&quot;, delay = 1 maxProcesses = 1 &#125;-- II. 本地目录同步，rsync模式：rsyncsync &#123; default.rsync, source = &quot;/tmp/src&quot;, target = &quot;/tmp/dest1&quot;, excludeFrom = &quot;/etc/rsyncd.d/rsync_exclude.lst&quot;, rsync = &#123; binary = &quot;/usr/bin/rsync&quot;, archive = true, compress = true, bwlimit = 2000 &#125; &#125;-- III. 远程目录同步，rsync模式 + rsyncd daemonsync &#123; default.rsync, source = &quot;/tmp/src&quot;, target = &quot;syncuser@172.29.88.223::module1&quot;, delete=&quot;running&quot;, exclude = &#123; &quot;.*&quot;, &quot;.tmp&quot; &#125;, delay = 30, init = false, rsync = &#123; binary = &quot;/usr/bin/rsync&quot;, archive = true, compress = true, verbose = true, password_file = &quot;/etc/rsyncd.d/rsync.pwd&quot;, _extra = &#123;&quot;--bwlimit=200&quot;&#125; &#125; &#125;-- IV. 远程目录同步，rsync模式 + ssh shellsync &#123; default.rsync, source = &quot;/tmp/src&quot;, target = &quot;172.29.88.223:/tmp/dest&quot;, -- target = &quot;root@172.29.88.223:/remote/dest&quot;, -- 上面target，注意如果是普通用户，必须拥有写权限 maxDelays = 5, delay = 30, -- init = true, rsync = &#123; binary = &quot;/usr/bin/rsync&quot;, archive = true, compress = true, bwlimit = 2000 -- rsh = &quot;/usr/bin/ssh -p 22 -o StrictHostKeyChecking=no&quot; -- 如果要指定其它端口，请用上面的rsh &#125; &#125;-- V. 远程目录同步，rsync模式 + rsyncssh，效果与上面相同sync &#123; default.rsyncssh, source = &quot;/tmp/src2&quot;, host = &quot;172.29.88.223&quot;, targetdir = &quot;/remote/dir&quot;, excludeFrom = &quot;/etc/rsyncd.d/rsync_exclude.lst&quot;, -- maxDelays = 5, delay = 0, -- init = false, rsync = &#123; binary = &quot;/usr/bin/rsync&quot;, archive = true, compress = true, verbose = true, _extra = &#123;&quot;--bwlimit=2000&quot;&#125;, &#125;, ssh = &#123; port = 1234 &#125; &#125; 上面的内容几乎涵盖了所有同步的模式，其中第III个要求像rsync一样配置rsyncd服务端，见本文开头。第IV、V配置ssh方式同步，达到的效果相同，但实际同步时你会发现每次同步都会提示输入ssh的密码，可以通过以下方法解决： 在远端被同步的服务器上开启ssh无密码登录，请注意用户身份： 1234user$ ssh-keygen -t rsa一路回车...user$ cd ~/.sshuser$ cat id_rsa.pub &gt;&gt; authorized_keys 把id_rsa私钥拷贝到执行lsyncd的机器上 123user$ chmod 600 ~/.ssh/id_rsa测试能否无密码登录user$ ssh user@172.29.88.223 3. lsyncd的其它功能lsyncd的功能不仅仅是同步，官方手册Lsyncd 2.1.x ‖ Layer 2 Config ‖ Advanced onAction高级功能提到，还可以监控某个目录下的文件，根据触发的事件自己定义要执行的命令，example是监控某个某个目录，只要是有jpg、gif、png格式的文件参数，就把它们转成pdf，然后同步到另一个目录。正好在我运维的一个项目中有这个需求，现在都是在java代码里转换，还容易出现异常，通过lsyncd可以代替这样的功能。但，门槛在于要会一点点lua语言（根据官方example还是可以写出来）。 另外偶然想到个问题，同时设置了maxDelays和delay，当监控目录一直没有文件变化了，也会发生同步操作，虽然没有可rsync的文件。 TO-DO： 其它同步工具：csync2，clsync，btsync，drdb 。 lsyncd双向同步：GlusterFS 参考 Lsyncd21Manual（本文很大一部分翻译自官网手册） 使用lsyncd配置数据库备份多异地同步 如何实时同步大量小文件 Lsyncd 测试远程、本地目录自动同步]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cenos7Yun安装Python3]]></title>
    <url>%2F2019%2F01%2F25%2FCenos7Yun%E5%AE%89%E8%A3%85Python3%2F</url>
    <content type="text"><![CDATA[安装EPEL和IUS软件源 yum install epel-release -y yum install https://centos7.iuscommunity.org/ius-release.rpm -y 安装Python3.6 yum install python36u -y 创建python3连接符 ln -s /bin/python3.6 /bin/python3 安装pip3 yum install python36u-pip -y 创建pip3链接符 ln -s /bin/pip3.6 /bin/pip3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
